66. Plus One
数组表示一个数,最后一位+1,生成新的数组
解决:直接解决;
=====

119. Pascal's Triangle II
输出第k行杨辉三角
解决:第k行=第k-1行+第k-1行错一位;
=====

561. Array Partition I
给2n个integers,group这些integers到n对，使得这n对的min(a,b)最大
解决:排序,index为奇数的元素相加
=====

1. Two Sum
给一个整形数组，一个target，返回加起来等于target的元素的下标
解决:使用额外空间,则使用hashmap.
=====

448. Find All Numbers Disappeared in an Array
给定一个大小为n的整形数组1<=a[i]<=n,一些出现两次，一些出现一次，在数组中找出所有没有出现过的的[1,n]的元素
解决:遍历一次,将访问所有存在的index值,将所有被访问到的index值为正数时变为负数(已经为负数时就不变了),那么最后还是正数的index就是没有被访问过的index,返回这些下标.
=====

167. Two Sum II - Input array is sorted
给定一个已经按升序排列的整形数组，找到两个加起来等于target的数。返回这两个数的数组下标，index1必须小于index2.
解决:两个指针,一个指向头index1,一个指向尾index2,如果和大于target,那么index2--,如果小于target,index1++
=====

26. Remove Duplicates from Sorted Array
给定一个大小为n的已排序数组，删除重复的地方，使每个元素只出现一次，并返回新的长度。
解决:遍历数组,并用一个指针指向新数组的末尾,如果新元素和末尾不相等,那么index++,且元素等于新元素
=====

27. Remove Element
给定一个数组和一个值，删除该值的所有实例，并返回新的长度
解决:遍历数组,并用一个指针指向新数组的末尾,如果新元素和target不相等,那么index++,且元素等于新元素
=====

169. Majority Element
给定一个大小为n的数组，找到出现大于[n/2]次数的元素。
解决:计数法,count,如果和前一个数相等就count++,否则count--
解决:快速排序,位于[n/2]的元素就是target
=====

581. Shortest Unsorted Continuous Subarray
给定一个整形数组，你需要找到一个连续子数组满足：如果改变这个子数组使之按升序排列，那么整个数组就能按升序排列.
解决:遍历两遍数组
第一遍从头到尾,找出最后一个小于最大值max的数
第二遍从尾到头,找出最后一个大于最小值min的数
=====

566. Reshape the Matrix
m*n矩阵转换为r*c的矩阵
解决:直接解决,根据个数关系进行转换
=====

35. Search Insert Position
给定一个已经排序的数组和定值，输出它所在的位置或者它应该插入的位置。
解决:如果找到,就返回所在位置
如果没有找到,就返回start所在位置,因为start就表明下一次它应该出现在哪里. start = mid + 1;
=====

88. Merge Sorted Array
给定两个已经排序的整形数组nums1和nums2，将两个数组整合（可以认为nums1的长度足够大）
解决:归并排序
=====

414. Third Maximum Number
给定一个非空整形数组,返回这个数组第三大的数,如果不存在,返回最大的数.(必须O(n))
解决:定义三个Integer,三种情况,直接解决.
=====

628. Maximum Product of Three Numbers
给定一个整型数组,找到乘积最大的三个数.
解决:排序,然后判断最大的三个数相乘结果和最小的两个数和最大的
=====

643. Maximum Average Subarray I
给定一个包含n个整形数的数组,找到连续的子数组长度为k有着最大的平均值.输出最大的平均值.
解决:用一个固定长度的窗,值为元素的和,不断移动,求最大值.
=====

283. Move Zeroes
给定一个数组,移动所有的0到数组最后并保持所有非0元素的相对位置.
解决:遍历数组,用一个指针,每次遇到不是0的++,遇到是0的不变.
=====

532. K-diff Pairs in an Array
给定一个整形数组和一个整数k,找到绝对差等于k共有几对.
解决:先用hashmap存储每个数字的个数,然后遍历keySet,求结果.
=====

121. Best Time to Buy and Sell Stock
第i个元素为第i天的股票价格,只能买卖一次,求最大的利润.
解决:遍历数组,如果该值小于最小值,设为买入,并一直保存最大利润的值.
=====

219. Contains Duplicate II
给定一个整型数组和一个整数k,找出是否存在下标是i和j的元素num[i] = num[j],且i和j的差值最大是k.
解决:使用hashmap保存之前的值
=====

217. Contains Duplicate
给定一个整型数组,找出是否含有重复的数字,如果出现两次以上返回true
解决:使用HashSet
=====

53. Maximum Subarray
找到数组的最大子数组
解决:遍历数组,如果该和小于0,设为最大子数组的开始,并一直保存最大子数组的值.
=====

118. Pascal's Triangle
返回杨辉三角的前i行
解决:求杨辉三角的第k行.
=====

485. Max Consecutive Ones
给定一个二进制数组,找出连续的1最大的长度.
解决:遍历数组,如果没有连续,则从新开始,并一直保存最大的长度.
=====

268. Missing Number
给定一个数组包含n个不同的数字,范围从0,1,2...n,找出那个消失的数字.
解决:把0到n全部异或一遍,然后再跟数组的每个元素异或一遍,那么剩下的那个就是只出现一次的元素.
=====

189. Rotate Array
用k步旋转一个n个元素的数组
解决:使用额外的存储空间.
=====

209. Minimum Size Subarray Sum
给定一个n个整数的和一个正数s,找出最小的子数组长度满足sum>=s,如果没有,返回0;
解决:一个头指针,一个尾指针,头指针==尾指针,并且一直推进,并一直保存最小长度.
=====

18. 4Sum
在数组中找出所有的4个数和等于target的组合
解决:使用2Sum,从一个头一个尾,然后中间使用2Sum
=====

16. 3Sum Closest
在数组中找出和target最近的三个数的和
解决:使用2Sum,从头指针开始,使用2Sum.
=====

15. 3Sum
在数组中找出和为target的三个数的所有组合.
解决:使用2Sum
=====

11. Container With Most Water
给定n个非负整数a1...an,每个数代表了左边i,ai.绘制n条垂线使得第i条线的两端是
i,ai和i,0.找到两条线,和x轴型形成一个容器,使得容器能装最多的水,不能倾斜容器.
解决:一个头指针,一个尾指针,前后推进,推向较大的一边.
=====

495. Teemo Attacking
给定一个数组,数组中的元素为攻击的时刻,计算中毒的总时间.
解决:遍历数组
=====

442. Find All Duplicates in an Array
给定一个整形数组,1<=a[i]<=n(数组的长度),一些元素出现两次,其他的出现一次.找出所有出现两次的元素.
解决:遍历数组,并进行负数标记,如果负数标记完了,发现是正数,那么该index就是target
=====
























































